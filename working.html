<html lang="en">
  <head>
    <!-- Scripts & Link for rangeSlider -->

    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ion-rangeslider/2.3.1/css/ion.rangeSlider.min.css" />-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ion-rangeslider/2.3.1/js/ion.rangeSlider.min.js"></script>

    <!-- Scripts & Link for Vis.js -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis.css"
      type="text/css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="https://unpkg.com/vis-network/styles/vis-network.min.css"
    />
    <script
      type="text/javascript"
      src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"
    ></script>

    <center>
      <h1 style="color: white">CognectEd</h1>
    </center>

    <meta name="referrer" content="no-referrer" />

    <style type="text/css">
      #mynetwork {
        width: 50%;
        height: 40vw;
        background-color: #222222;
        border: 1px solid lightgray;
        position: relative;
        margin: 0 auto;
        float: center;
      }

      #loadingBar {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 1500px;
        background-color: rgba(200, 200, 200, 0.8);
        -webkit-transition: all 0.5s ease;
        -moz-transition: all 0.5s ease;
        -ms-transition: all 0.5s ease;
        -o-transition: all 0.5s ease;
        transition: all 0.5s ease;
        opacity: 1;
      }

      #bar {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 20px;
        height: 20px;
        margin: auto auto auto auto;
        border-radius: 11px;
        border: 2px solid rgba(30, 30, 30, 0.05);
        background: rgb(0, 173, 246);
        /* Old browsers */
        box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.4);
      }

      #border {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 500px;
        height: 23px;
        margin: auto auto auto auto;
        box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }

      #text {
        position: absolute;
        top: 8px;
        left: 530px;
        width: 30px;
        height: 50px;
        margin: auto auto auto auto;
        font-size: 22px;
        color: #000000;
      }

      div.outerBorder {
        position: relative;
        top: 400px;
        width: 600px;
        height: 44px;
        margin: auto auto auto auto;
        border: 8px solid rgba(0, 0, 0, 0.1);
        background: rgb(252, 252, 252);
        /* Old browsers */
        background: -moz-linear-gradient(
          top,
          rgba(252, 252, 252, 1) 0%,
          rgba(237, 237, 237, 1) 100%
        );
        /* FF3.6+ */
        background: -webkit-gradient(
          linear,
          left top,
          left bottom,
          color-stop(0%, rgba(252, 252, 252, 1)),
          color-stop(100%, rgba(237, 237, 237, 1))
        );
        /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(
          top,
          rgba(252, 252, 252, 1) 0%,
          rgba(237, 237, 237, 1) 100%
        );
        /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(
          top,
          rgba(252, 252, 252, 1) 0%,
          rgba(237, 237, 237, 1) 100%
        );
        /* Opera 11.10+ */
        background: -ms-linear-gradient(
          top,
          rgba(252, 252, 252, 1) 0%,
          rgba(237, 237, 237, 1) 100%
        );
        /* IE10+ */
        background: linear-gradient(
          to bottom,
          rgba(252, 252, 252, 1) 0%,
          rgba(237, 237, 237, 1) 100%
        );
        /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fcfcfc', endColorstr='#ededed', GradientType=0);
        /* IE6-9 */
        border-radius: 72px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
      }

      /* position absolute is important and the container has to be relative or absolute as well. */
      div.popup {
        position: absolute;
        top: 0px;
        left: 0px;
        display: none;
        background-color: #f5f4ed;
        -moz-border-radius: 3px;
        -webkit-border-radius: 3px;
        border-radius: 3px;
        border: 1px solid #808074;
        box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
      }

      /* hide the original tooltip */
      /* .vis-network-tooltip {
        display: none;
      } */

      .btn_Test {
        box-shadow: inset 0px 1px 0px 0px #ffffff;
        background: linear-gradient(to bottom, #ffffff 5%, #f6f6f6 100%);
        background-color: #ffffff;
        border-radius: 6px;
        border: 1px solid #dcdcdc;
        display: inline-block;
        cursor: pointer;
        color: #666666;
        font-family: Arial;
        font-size: 15px;
        font-weight: bold;
        padding: 17px 57px;
        text-decoration: none;
        text-shadow: 0px 1px 0px #ffffff;
        margin-top: 15px;
      }

      .btn_Test:hover {
        background: linear-gradient(to bottom, #f6f6f6 5%, #ffffff 100%);
        background-color: #f6f6f6;
      }

      .btn_Test:active {
        position: relative;
        top: 1px;
      }

      .container-RS {
        max-width: 50%;
      }

      select {
        text-align: center;
        text-align-last: center;
        -moz-text-align-last: center;
      }
    </style>
  </head>

  <body style="background-color: #222222">
    <div id="mynetwork"></div>

    <center>
      <!--<a href="#" class="btn_Test" onclick="btn_testClick()">Test</a>-->

      <br />
      <br />

      <label for="courseId" style="color: white">Course</label>
      <select
        name="course"
        id="course"
        onchange="FetchData(this.value)"
        style="text-align: center"
      >
        <option value="" disabled selected>Select</option>
      </select>
      <br />
      <br />

      <!--<label for="student" style="color: white">Selected Student</label>
      <select name="students" id="students" onchange="SelectedStudentChanged(this.value)" style="text-align:center">
        <option value="">All Enrolled Students</option>
      </select>
      <br /> <br />-->

      <label for="accesskey" style="color: white">Access Token</label>
      <input
        type="text"
        id="accesskey"
        name="accesskey"
        value="7236~8dQSbbxT2iQeatKfNOJYzWR441OHkkv5CcUOr4sksrHNmdk1SRQoJG5wrut4e0s7"
        size="85px"
        style="text-align: center"
        onchange="SetTokenCookie()"
        onkeyup="SetTokenCookie"
      />
      <br />
      <br />

      <!--<div class="container-RS">
        <input type="text" class="js-range-slider-1" name="my_range" value="" />
      </div>-->
    </center>

    <!-- <div id="loadingBar">
      <div class="outerBorder">
        <div id="text">0%</div>
        <div id="border">
          <div id="bar"></div>
        </div>
      </div>
    </div> -->

    <script type="text/javascript">
      //Deployed at http://www.public.asu.edu/~ntroksa/working.html#
      // initialize global variables.
      var edges;
      var nodes;
      var network;
      var container;
      var options, data;
      var allNodes;
      var nodeDataset;
      var highlightActive = false;
      var courses = [];
      var courseAssignmentData;
      var courseGradeData;
      var Assignments = {};
      var Keywords = [];
      var keywordCount = 0;
      var corsAnywhere = "https://salty-atoll-62320.herokuapp.com/"; //NEEDED TO CREATE A 'PROPER' CORS API CALL

      //Cookies
      function SetCookie(name, value, days) {
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
          var expires = "; expires=" + date.toUTCString();
        } else {
          var expires = "";
        }

        document.cookie =
          name + "=" + encodeURIComponent(value) + expires + "; path =/";
      }

      function GetCookie(name) {
        var nameEQ = name + "=";
        //handle special characters
        var decodeCookie = decodeURIComponent(document.cookie);
        var ca = decodeCookie.split(";");
        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];
          while (c.charAt() == " ") {
            c = c.substring(1, c.length);
          }

          if (c.indexOf(nameEQ) == 0) {
            return c.substring(nameEQ.length, c.length);
          }
        }

        return null;
      }

      function EraseCookie(name) {
        SetCookie(name, "", -1);
      }

      function CheckCookie() {
        var token = GetCookie("token");
        var nameOfClass = GetCookie("nameOfClass");
        if (
          token != "" &&
          token != null &&
          nameOfClass != "" &&
          nameOfClass != null
        ) {
          //alert("Here is your saved token: " + token + " and here is your saved class " + nameOfClass)

          document.getElementById("course").value = nameOfClass;
          document.getElementById(("accesskey".value = token));

          FetchData(nameOfClass);
        } else {
          SetTokenCookie();
          SetClassCookie();
        }
      }

      function SetTokenCookie() {
        token = document.getElementById("accesskey").value; //insert variables

        if(token != "" && token != null && token.length > 60){
          SetCookie("token", token, 365)
          GetCourseData()
        }
      }

      function SetClassCookie() {
        nameOfClass = document.getElementById("course").value; //insert variables

        if (nameOfClass != "" && nameOfClass != null) {
          SetCookie("nameOfClass", nameOfClass, 365);
        }
      }

      //NJT Access key 7236~8dQSbbxT2iQeatKfNOJYzWR441OHkkv5CcUOr4sksrHNmdk1SRQoJG5wrut4e0s7
      //this is called each time the selected value for the "courses" dropdownlist is changed
      async function FetchData(courseName) {
        //Retrieve relevant information for the API call
        accesskey = document.getElementById("accesskey").value;
        var courseID = GetCourseIDByName(courseName);

        SetClassCookie();

        AjaxCallAssignments(courseID, accesskey);

        /*
        //Class enrollment call no longer needed until further notice
        try{
          //Canvas API call to retrive student data for the given course
          res = await $.ajax({
            url: corsAnywhere + 'https://asu.instructure.com/api/v1/courses/' + courseID + '/enrollments?per_page=100',
            datatype: "jsonp",
            headers: {"Authorization": "Bearer " + accesskey,
                      "x-requested-with": "xhr"},
            success: async function(res, status, xhr) {
              await sleep(75)

              console.log("STUDENTS");
              var remainingPages = xhr.getResponseHeader("link");
              courseStudentData = res

              //checks that the remaing pages header is active
              if (remainingPages != null) {
                //clear out the student data
                document.getElementById("students").disabled = true;
                document.getElementById("students").innerHTML = "<option>All Enrolled Students</option>";
                await ReturnAllRemaining(remainingPages, accesskey, "Students");
                //GetStudentsInCourse(courseStudentData);
              }

              GetStudentsInCourse(courseStudentData);
            },
            error: function(xhr, status, error) {
              console.log(xhr.responseText);
            },
          })
        }
        catch (e){
          console.log(e);
        }
        */
      }

      //Ajax function to call assignment data
      async function AjaxCallAssignments(courseID, accesskey) {
        try {
          //Canvas API call for the ASSIGNMENT for the given course
          $.ajax({
            url:
              corsAnywhere +
              "https://asu.instructure.com/api/v1/courses/" +
              courseID +
              "/assignments?per_page=100",
            datatype: "jsonp",
            headers: {
              Authorization: "Bearer " + accesskey,
              "x-requested-with": "xhr",
            },
            success: async function (res, status, xhr) {
              await sleep(75);
              console.log("ASSIGNMENTS");
              var remainingPages = xhr.getResponseHeader("link");
              courseAssignmentData = res;

              if (remainingPages != null) {
                await ReturnAllRemaining(
                  remainingPages,
                  accesskey,
                  "Assignments"
                );
              }

              ParseJsonToAssignment();

              AjaxCallGrade(courseID, accesskey);
            },
            error: function (xhr, status, error) {
              console.log(xhr.responseText);
            },
          });
        } catch (e) {
          console.log(e);
        }
      }

      //Ajax function to call grade data
      async function AjaxCallGrade(courseID, accesskey) {
        try {
          //Canvas API call for the grade history for the given course
          $.ajax({
            url:
              corsAnywhere +
              "https://asu.instructure.com/api/v1/courses/" +
              courseID +
              "/gradebook_history/feed?per_page=100",
            datatype: "json",
            headers: {
              Authorization: "Bearer " + accesskey,
              "x-requested-with": "xhr",
            },
            success: async function (res, status, xhr) {
              await sleep(75);
              console.log("GRADEBOOK HISTORY");
              var remainingPages = xhr.getResponseHeader("link");
              courseGradeData = res;

              if (remainingPages != null) {
                await ReturnAllRemaining(
                  remainingPages,
                  accesskey,
                  "Grades"
                ).then();
              }

              ParseGradeJson();
            },
            error: function (xhr, status, error) {
              console.log(xhr.responseText);
            },
          });
        } catch (e) {
          console.log(e);
        }
      }

      //parse the assignment data for the course
      function ParseJsonToAssignment() {
        if (courseAssignmentData != undefined) {
          courseAssignmentData.forEach((item, i) => {
            Assignments[item.id] = new Assignment(
              item.id,
              item.name,
              item.description,
              item.points_possible
            );
          });
        }
      }

      //Parse the grade data for the course
      function ParseGradeJson() {
        if (courseGradeData != undefined) {
          courseGradeData.forEach((item, i) => {
            Assignments[item.assignment_id].AppendGrade(item);
          });

          for (let id in Assignments) {
            Assignments[id].CalcAssignmentAverage();
          }

          for (i = 0; i < Keywords.length; i++) {
            Keywords[i].CalcKeywordAverage();
          }

          console.log("ASSIGNMENT OBJECTS");
          console.log(Assignments);

          console.log("KEYWORD OBJECTS");
          console.log(Keywords);

          drawGraph();
        }
      }

      //helper for ParseLinkHead Function
      //from https://bill.burkecentral.com/2009/10/15/parsing-link-headers-with-javascript-and-java/
      function unquote(value) {
        if (value.charAt(0) == '"' && value.charAt(value.length - 1) == '"')
          return value.substring(1, value.length - 1);
        return value;
      }

      //function to parse the link header
      //from https://bill.burkecentral.com/2009/10/15/parsing-link-headers-with-javascript-and-java/
      function ParseLinkHead(value) {
        var linkexp = /<[^>]*>\s*(\s*;\s*[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|$)/g;
        var paramexp = /[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g;

        var matches = value.match(linkexp);
        var rels = new Object();
        var titles = new Object();
        for (i = 0; i < matches.length; i++) {
          var split = matches[i].split(">");
          var href = split[0].substring(1);
          var ps = split[1];
          var link = new Object();
          link.href = href;
          var s = ps.match(paramexp);
          for (j = 0; j < s.length; j++) {
            var p = s[j];
            var paramsplit = p.split("=");
            var name = paramsplit[0];
            link[name] = unquote(paramsplit[1]);
          }

          if (link.rel != undefined) {
            rels[link.rel] = link;
          }
          if (link.title != undefined) {
            titles[link.title] = link;
          }
        }
        var linkheader = new Object();
        linkheader.rels = rels;
        linkheader.titles = titles;
        return linkheader;
      }

      //function allows for application to 'halt' for x ms
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      //Function to retrieve all remaining json data if there are more than 100 results from the previous call
      async function ReturnAllRemaining(linkHeader, accesskey, callType) {
        var linkParser = ParseLinkHead(linkHeader);
        var remainingPages;

        //while there is no last page or the current page does not equal the last page
        while (
          linkParser.rels.last === undefined ||
          linkParser.rels.current.href != linkParser.rels.last.href
        ) {
          await $.ajax({
            url: corsAnywhere + linkParser.rels.next.href,
            datatype: "jsonp",
            headers: {
              Authorization: "Bearer " + accesskey,
              "x-requested-with": "xhr",
            },
            success: async function (res, status, xhr) {
              await sleep(50);
              remainingPages = xhr.getResponseHeader("link");

              //make sure that there was a link header in the last call
              if (remainingPages != null && remainingPages != undefined) {
                console.log("New Page " + callType);

                if (callType == "Students") {
                  courseStudentData = courseStudentData.concat(res);
                } else if (callType == "Grades") {
                  courseGradeData = courseGradeData.concat(res);
                } else if (callType == "Assignments") {
                  courseAssignmentData = courseGradeData.concat(res);
                }

                //set the current linkparser to the new link header
                linkParser = ParseLinkHead(remainingPages);
              }
            },
            error: function (xhr, status, error) {
              console.log(xhr.responseText);
            },
          });

          await sleep(100);
        }
      }

      //concatenate the given enrollment data to the students list
      function GetStudentsInCourse(enrollmentData) {
        //variable to concatenate onto the current classes
        var catOptions = document.getElementById("students").innerHTML;

        //foreach iterates through all the students
        enrollmentData.forEach((item, i) => {
          if (item.user.name != undefined && item.type == "StudentEnrollment") {
            catOptions += "<option>" + item.user.name + "</option>";
          }
        });

        document.getElementById("students").innerHTML = catOptions;

        document.getElementById("students").disabled = false;
      }

      //event raised when the selected student list value is changed
      //May not be needed due to current node structure
      function SelectedStudentChanged(studentName) {}

      //Populates the course list with the given class data
      //concatenates the data with the current data in the course list
      function PopulateCourses(classData) {
        var catOptions = document.getElementById("course").innerHTML;
        courses = courses.concat(classData);

        classData.forEach((item, i) => {
          if (item.name != undefined) {
            catOptions += "<option>" + item.name + "</option>";
          }
        });

        document.getElementById("course").innerHTML = catOptions;

        CheckCookie();
      }

      function GetCourseByID(courses, courseID) {
        return courses.find((course) => course.id === courseID);
      }

      function GetCourseIDByName(courseName) {
        return courses.find((course) => course.name === courseName).id;
      }

      //Get the course data with the given enrollment types
      function GetCourseData() {
        //will need to remove the StudentEnrollment type for the final product. In use now for demo purposes
        var enrollmentTypes = [
          "StudentEnrollment",
          "TeacherEnrollment",
          "TaEnrollment",
          "ObserverEnrollment",
          "DesignerEnrollment",
        ];
        accesskey = document.getElementById("accesskey").value;

        //get course data for each enrollment type
        enrollmentTypes.forEach((item, i) => {
          $.ajax({
            url:
              corsAnywhere +
              "https://asu.instructure.com/api/v1/courses?enrollment_role=" +
              item,
            datatype: "json",
            method: "GET",
            headers: {
              "x-requested-with": "xhr",
              Authorization: "Bearer " + accesskey,
            },
            beforeSend: function (xhr) {
              //xhr.setRequestHeader("Authorization", "Bearer " + accesskey);
            },
            success: function (jsondata) {
              if (jsondata.length != 0) {
                PopulateCourses(jsondata);
              }
            },
            error: function (xhr, status, error) {
              console.log(xhr.responseText);
            },
          });
        });
      }

      function edgeExists(edge, edges) {
        let answer = false;
        edges.forEach((currentEdge) => {
          if (
            (edge.to == currentEdge.to && edge.from == currentEdge.from) ||
            (edge.to == currentEdge.from && edge.from == currentEdge.to)
          ) {
            answer = true;
          }
        });
        return answer;
      }

      function createKeywordNodes() {
        let nodes = [];
        Keywords.forEach((keyword) => {
          let nodeJson = {};
          nodeJson.id = KeywordIndex(keyword.name);
          nodeJson.title =
            "<b>" +
            keyword.name +
            "</b><br/><b>Class Grade Average: </b>" +
            keyword.keyword_Avg +
            "%";
          nodeJson.value = keyword.keyword_Avg;
          nodes.push(nodeJson);
        });

        return nodes;
      }

      function createEdges() {
        let edges = [];
        Keywords.forEach((keyword) => {
          let edgeJson = {};
          let graded = true;
          edgeJson.from = KeywordIndex(keyword.name);
          for (let keywordName in keyword.associatedKeys) {
            edgeJson.to = KeywordIndex(keywordName);
            // Calculate the edge average.
            let edgeAverage = CalcAssignmentListAvg(
              keyword.associatedKeys[keywordName]
            );
            edgeJson.length = Math.round(100 - edgeAverage + 1) + 100;
            edgeJson.title = "<b>Class Grade Average: </b>" + edgeAverage + "%";
            if (edgeAverage == -1) {
              graded = false;
            }
          }

          if (!edgeExists(edgeJson, edges) && graded) {
            console.log(edgeJson.title + " " + edgeJson.length);
            edges.push(edgeJson);
          }
        });

        return edges;
      }

      // This method is responsible for drawing the graph, returns the drawn network
      function drawGraph() {
        var container = document.getElementById("mynetwork");

        // parsing and collecting nodes and edges from the python
        let keywordNodes = createKeywordNodes();
        let keywordEdges = createEdges();
        // adding nodes and edges to the graph
        data = {
          nodes: keywordNodes,
          edges: keywordEdges,
        };

        var options = {
          nodes: {
            shape: "dot",
            scaling: {
              customScalingFunction: function (min, max, total, value) {
                return value * 0.005;
              },
              min: 0,
              max: 100,
            },
          },
          edges: {
            smooth: false,
            width: 2,
          },
          physics: {
            barnesHut: {
              avoidOverlap: 1,
              springConstant: 0.1,
              centralGravity: 0.5,
            },
          },
          interaction: {
            hover: false,
          },
        };

        network = new vis.Network(container, data, options);

        // get a JSON object
        // allNodes = nodes.get({
        //   returnType: "Object",
        // });

        // network.on("click", function (params) {
        //   neighbourhoodHighlight(params);
        // });

        // make a custom popup
        // var popup = document.createElement("div");
        // popup.className = "popup";
        // popupTimeout = 500000;
        // popup.addEventListener("mouseover", function () {
        //   console.log(popup);
        //   if (popupTimeout !== null) {
        //     clearTimeout(popupTimeout);
        //     popupTimeout = null;
        //   }
        // });
        // popup.addEventListener("mouseout", function () {
        //   if (popupTimeout === null) {
        //     hidePopup();
        //   }
        // });
        // container.appendChild(popup);

        // // use the popup event to show
        // network.on("showPopup", function (params) {
        //   showPopup(params);
        // });

        // // use the hide event to hide it
        // network.on("hidePopup", function (params) {
        //   hidePopup();
        // });

        // // hiding the popup through css
        // function hidePopup() {
        //   popupTimeout = setTimeout(function () {
        //     popup.style.display = "none";
        //   }, 500);
        // }

        // // showing the popup
        // function showPopup(nodeId) {
        //   // get the data from the vis.DataSet
        //   var nodeData = nodes.get([nodeId]);
        //   popup.innerHTML = nodeData[0].title;

        //   // get the position of the node
        //   var posCanvas = network.getPositions([nodeId])[nodeId];

        //   // get the bounding box of the node
        //   var boundingBox = network.getBoundingBox(nodeId);

        //   //position tooltip:
        //   posCanvas.x =
        //     posCanvas.x + 0.5 * (boundingBox.right - boundingBox.left);

        //   // convert coordinates to the DOM space
        //   var posDOM = network.canvasToDOM(posCanvas);

        //   // Give it an offset
        //   posDOM.x += 10;
        //   posDOM.y -= 20;

        //   // show and place the tooltip.
        //   popup.style.display = "block";
        //   popup.style.top = posDOM.y + "px";
        //   popup.style.left = posDOM.x + "px";
        // }

        // network.on("stabilizationProgress", function (params) {
        //   document.getElementById("loadingBar").removeAttribute("style");
        //   var maxWidth = 496;
        //   var minWidth = 20;
        //   var widthFactor = params.iterations / params.total;
        //   var width = Math.max(minWidth, maxWidth * widthFactor);

        //   document.getElementById("bar").style.width = width + "px";
        //   document.getElementById("text").innerHTML =
        //     Math.round(widthFactor * 100) + "%";
        // });
        // network.once("stabilizationIterationsDone", function () {
        //   document.getElementById("text").innerHTML = "100%";
        //   document.getElementById("bar").style.width = "496px";
        //   document.getElementById("loadingBar").style.opacity = 0;
        //   // really clean the dom element
        //   setTimeout(function () {
        //     document.getElementById("loadingBar").style.display = "none";
        //   }, 500);
        // });

        return network;
      }

      //used to highlight nodes may change based on generating code
      function neighbourhoodHighlight(params) {
        // if something is selected:
        if (params.nodes.length > 0) {
          highlightActive = true;
          var i, j;
          var selectedNode = params.nodes[0];
          var degrees = 1;

          // mark all nodes as hard to read.
          for (var nodeId in allNodes) {
            allNodes[nodeId].color = "rgba(200,200,200,0.5)";
            if (allNodes[nodeId].hiddenLabel === undefined) {
              allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
              allNodes[nodeId].label = undefined;
            }
          }
          var connectedNodes = network.getConnectedNodes(selectedNode);
          var allConnectedNodes = [];

          // get the second degree nodes
          for (i = 1; i < degrees; i++) {
            for (j = 0; j < connectedNodes.length; j++) {
              allConnectedNodes = allConnectedNodes.concat(
                network.getConnectedNodes(connectedNodes[j])
              );
            }
          }

          // all second degree nodes get a different color and their label back
          for (i = 0; i < allConnectedNodes.length; i++) {
            allNodes[allConnectedNodes[i]].color = "rgba(150,150,150,0.75)";
            if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
              allNodes[allConnectedNodes[i]].label =
                allNodes[allConnectedNodes[i]].hiddenLabel;
              allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
            }
          }

          // all first degree nodes get their own color and their label back
          for (i = 0; i < connectedNodes.length; i++) {
            allNodes[connectedNodes[i]].color = undefined;
            if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
              allNodes[connectedNodes[i]].label =
                allNodes[connectedNodes[i]].hiddenLabel;
              allNodes[connectedNodes[i]].hiddenLabel = undefined;
            }
          }

          // the main node gets its own color and its label back.
          allNodes[selectedNode].color = undefined;
          if (allNodes[selectedNode].hiddenLabel !== undefined) {
            allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
            allNodes[selectedNode].hiddenLabel = undefined;
          }
        } else if (highlightActive === true) {
          // reset all nodes
          for (var nodeId in allNodes) {
            //added if statement to fix greying out bug on all nodes in group 10
            if (allNodes[nodeId].group == 10) {
              allNodes[nodeId].color = "rgba(128,0,128,1)";
            } else {
              allNodes[nodeId].color = undefined;
            }

            if (allNodes[nodeId].hiddenLabel !== undefined) {
              allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
              allNodes[nodeId].hiddenLabel = undefined;
            }
          }
          highlightActive = false;
        }

        // transform the object into an array
        var updateArray = [];
        for (nodeId in allNodes) {
          if (allNodes.hasOwnProperty(nodeId)) {
            updateArray.push(allNodes[nodeId]);
          }
        }
        nodes.update(updateArray);
      }

      //event raised when the test button is clicked
      function btn_testClick() {
        console.log("Button Test Clicked");
      }

      //place holder function may not be used
      function RemakeNodeStructure() {}

      //place holder function may not be used
      function RemakeEdgeStructure() {}

      //Function from Azaria.
      //Used to parse out keywords from an assignment description
      function ParseKeywords(description) {
        var regexp = /(\s|^)#\w\w+\b/gm;
        let result = description.match(regexp);
        if (result) {
          result = result.map((keyword) => {
            keyword = keyword.trim();
            keyword = keyword.replace(/[_-]/g, " ");
            return keyword.substring(1);
          });

          return result;
        } else {
          return false;
        }
      }

      //returns the index of the keyword
      function KeywordIndex(keyword) {
        for (i = 0; i < Keywords.length; i++) {
          if (Keywords[i].name == keyword) {
            return i;
          }
        }

        return -1;
      }

      //checks if the keyword exists and appends additional associated keywords if they are not on the list
      function HandleKeywords(keywords, id) {
        keywords.forEach((item, i) => {
          var keyIdx = KeywordIndex(item);
          if (keyIdx == -1) {
            Keywords.push(new Keyword(item));
            keyIdx = Keywords.length - 1;
          }

          Keywords[keyIdx].AppendAssignment(id);
          Keywords[keyIdx].AppendToAssociatedKey(keywords, id);
        });
      }

      //Calculates the average of assignments given a list
      //expects an array of assignment ID's
      function CalcAssignmentListAvg(assignments) {
        var total = 0;
        var notGradedCount = 0;

        assignments.forEach((item, i) => {
          if (Assignments[item].average != -1) {
            total += Assignments[item].average;
          } else {
            notGradedCount += 1;
          }
        });

        var assignmentCount = assignments.length - notGradedCount;
        var KeywordAvg = -1;
        if (assignmentCount != 0) {
          KeywordAvg = parseFloat((total / assignmentCount).toFixed(1));
        }

        return KeywordAvg;
      }

      //declaration for the assignment class
      class Assignment {
        constructor(id, name, desc, pts_Possible) {
          this.id = id;
          this.name = name;
          this.desc = desc;
          this.totalPts = pts_Possible;
          this.grades = {};
          this.average = -1;

          //check if this assignment is extraCredit
          if (this.totalPts == 0) {
            this.extraCredit = true;
          } else {
            this.extraCredit = false;
          }

          //if the description is not blank or null
          if (this.desc != null && this.desc != "") {
            var div = document.createElement("div");
            div.innerHTML = desc;

            this.keywords = ParseKeywords(
              div.textContent || div.innerText || ""
            );

            //if there were keywords in the description
            if (this.keywords != false) {
              HandleKeywords(this.keywords, this.id);
            }
          }
        }

        //appends the given grade to the grade list if the ID matches
        AppendGrade(gradeObject) {
          //if this assignment was extra credit just make the grade to be 100
          if (this.totalPts == 0) {
            this.grades[gradeObject.user_name] = 100.0;
          } else {
            var roundedGrade = parseFloat(
              ((gradeObject.current_grade / this.totalPts) * 100).toFixed(1)
            );

            //if this assignment contained extraCredit make the flag true
            if (roundedGrade > 100) {
              this.extraCredit = true;
            }

            this.grades[gradeObject.user_name] = roundedGrade;
          }
        }

        //function to calculate the total assignment average
        CalcAssignmentAverage() {
          var total = 0;
          var count = Object.keys(this.grades).length;
          for (let key in this.grades) {
            total += this.grades[key];
          }

          if (count == 0) {
            this.average = -1;
          } else {
            this.average = parseFloat((total / count).toFixed(1));
          }
        }
      }

      class Keyword {
        constructor(name) {
          this.name = name;
          this.keyword_Avg = 0;
          this.associatedKeys = {};
          this.assignments = [];

          //used for later features
          this.category = null;
        }

        //function to calculate the total assignment average
        CalcKeywordAverage() {
          this.keyword_Avg = CalcAssignmentListAvg(this.assignments);
        }

        //appends the given assignment to the assignments list
        AppendAssignment(assignmentID) {
          this.assignments.push(assignmentID);
        }

        //appends the given keywords to the associatedKeys list
        AppendToAssociatedKey(keywords, assignmentID) {
          keywords.forEach((item, i) => {
            if (item != this.name) {
              if (this.associatedKeys[item] == undefined) {
                this.associatedKeys[item] = [];
              }

              this.associatedKeys[item].push(assignmentID);
            }
          });
        }
      }

      class Category {
        constructor(name, color, id) {
          this.name = name;
          this.color = color;
          this.id = id;
        }
      }

      //************************** start of main() **************************

      $(document).ready(function () {
        GetCourseData();
      });

      //Rangeslide may no longer be needed
      // $(".js-range-slider-1").ionRangeSlider({
      //   skin: "sharp",
      //   type: "double",
      //   min: 0,
      //   max: 100,
      //   from: 20,
      //   to: 50,
      //   step: 10,
      //   grid: true,
      //   grid_num: 10,
      //   force_edges: true
      // });

      // drawGraph();
    </script>
  </body>
</html>
